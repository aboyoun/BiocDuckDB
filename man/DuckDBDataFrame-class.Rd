% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DuckDBDataFrame-class.R
\name{DuckDBDataFrame-class}
\alias{DuckDBDataFrame-class}
\alias{length,DuckDBDataFrame-method}
\alias{names,DuckDBDataFrame-method}
\alias{rownames<-,DuckDBDataFrame-method}
\alias{colnames<-,DuckDBDataFrame-method}
\alias{names<-,DuckDBDataFrame-method}
\alias{DuckDBDataFrame}
\alias{[[,DuckDBDataFrame-method}
\alias{[,DuckDBDataFrame,ANY,ANY,ANY-method}
\alias{replaceROWS,DuckDBDataFrame-method}
\alias{replaceCOLS,DuckDBDataFrame-method}
\alias{[[<-,DuckDBDataFrame-method}
\alias{normalizeSingleBracketReplacementValue,DuckDBDataFrame-method}
\alias{subset,DuckDBDataFrame-method}
\alias{cbind,DuckDBDataFrame-method}
\alias{cbind.DuckDBDataFrame}
\alias{as.data.frame,DuckDBDataFrame-method}
\alias{coerce,DuckDBDataFrame,DFrame-method}
\alias{realize,DuckDBDataFrame-method}
\alias{makeNakedCharacterMatrixForDisplay,DuckDBDataFrame-method}
\alias{show,DuckDBDataFrame-method}
\title{DuckDBDataFrame objects}
\description{
The DuckDBDataFrame class extends both \linkS4class{DuckDBTable} and
\linkS4class{DataFrame} to represent a DuckDB table as a
\linkS4class{DataFrame} object.
}
\details{
DuckDBDataFrame adds \linkS4class{DataFrame} semantics to a DuckDB table.
It achieves a balance between the flexibility of a tbl_duckdb_connection
object and the familiarity of a \linkS4class{DataFrame} object.
}
\section{Constructor}{

\describe{
  \item{\code{DuckDBDataFrame(conn, datacols = colnames(conn), keycol = NULL, dimtbl = NULL, type = NULL)}:}{
    Creates a DuckDBDataFrame object.
    \describe{
      \item{\code{conn}}{
        Either a character vector containing the paths to parquet, csv, or
        gzipped csv data files; a string that defines a duckdb \code{read_*}
        data source; a DuckDBDataFrame object; or a tbl_duckdb_connection
        object.
      }
      \item{\code{datacols}}{
        Either a character vector of column names from \code{conn} or a
        named \code{expression} that will be evaluated in the context of
        \code{conn} that defines the data.
      }
      \item{\code{keycol}}{
        An optional string specifying the column name from \code{conn} that
        will define the foreign key in the underlying table, or a named list
        containing a character vector where the name of the list element
        defines the foreign key and the character vector set the distinct
        values for that key. If missing, a \code{row_number} column is
        created as an identifier.
      }
      \item{\code{dimtbl}}{
        A optional named \code{DataFrameList} that specifies the dimension
        table associated with the \code{keycol}. The name of the list
        element must match the name of the \code{keycol} list. Additionally,
        the \code{DataFrame} object must have row names that match the
        distinct values of the \code{keycol} list element and columns
        that define partitions in the data table for efficient querying.
      }
      \item{\code{type}}{
        An optional named character vector where the names specify the
        column names and the values specify the column type; one of
        \code{"logical"}, \code{"integer"}, \code{"integer64"},
        \code{"double"}, or \code{"character"}.
      }
    }
  }
}
}

\section{Accessors}{

In the code snippets below, \code{x} is a DuckDBDataFrame object:
\describe{
  \item{\code{dim(x)}:}{
    Length two integer vector defined as \code{c(nrow(x), ncol(x))}.
  }
  \item{\code{nrow(x)}, \code{ncol(x)}:}{
    Get the number of rows and columns, respectively.
  }
  \item{\code{NROW(x)}, \code{NCOL(x)}:}{
    Same as \code{nrow(x)} and \code{ncol(x)}, respectively.
  }
  \item{\code{dimnames(x)}:}{
    Length two list of character vectors defined as
    \code{list(rownames(x), colnames(x))}.
  }
  \item{\code{rownames(x)}, \code{colnames(x)}:}{
    Get the names of the rows and columns, respectively.
  }
  \item{\code{coltypes(x)}, \code{coltypes(x) <- value}:}{
    Get or set the data type of the columns; one of \code{"logical"},
    \code{"integer"}, \code{"integer64"}, \code{"double"}, or
    \code{"character"}.
  }
  \item{\code{dimtbls(x)}, \code{dimtbls(x) <- value}:}{
    Get or set the list of dimension tables used to define partitions for
    efficient queries.
  }
}
}

\section{Coercion}{

\describe{
  \item{\code{as.data.frame(x)}:}{
    Coerces \code{x} to a data.frame.
  }
  \item{\code{as(from, "DFrame")}:}{
    Converts a DuckDBDataFrame object to a DFrame object. This process
    involves first loading the data into memory using \code{as.data.frame}.
    The resulting data.frame is then coerced into a DFrame. Additionally,
    any associated metadata and mcols (metadata columns) are preserved and
    added to the DFrame, if they exist.
  }
  \item{\code{realize(x, BACKEND = getAutoRealizationBackend())}:}{
    Realize an object into memory or on disk using the equivalent of
    \code{realize(as(x, "DFrame"), BACKEND)}.
  }
}
}

\section{Subsetting}{

In the code snippets below, \code{x} is a DuckDBDataFrame object:
\describe{
  \item{\code{x[i, j, drop = TRUE]}:}{
    Returns either a new DuckDBDataFrame object or a DuckDBColumn if
    selecting a single column and \code{drop = TRUE}.
  }
  \item{\code{x[[i]]}:}{
    Extracts a DuckDBColumn object from \code{x}.
  }
  \item{\code{x[[i]] <- value}:}{
   Replaces column \code{i} in \code{x} with \code{value}.
  }
  \item{\code{head(x, n = 6L)}:}{
    If \code{n} is non-negative, returns the first n rows of \code{x}.
    If \code{n} is negative, returns all but the last \code{abs(n)} rows of
    \code{x}.
  }
  \item{\code{tail(x, n = 6L)}:}{
    If \code{n} is non-negative, returns the last n rows of \code{x}.
    If \code{n} is negative, returns all but the first \code{abs(n)} rows of
    \code{x}.
  }
  \item{\code{subset(x, subset, select, drop = FALSE)}:}{
    Return a new DuckDBDataFrame using:
    \describe{
      \item{subset}{logical expression indicating rows to keep, where missing
         values are taken as FALSE.}
       \item{select}{expression indicating columns to keep.}
       \item{drop}{passed on to \code{[} indexing operator.}
    }
  }
}
}

\section{Combining}{

\describe{
  \item{\code{cbind(...)}:}{
    Creates a new DuckDBDataFrame object by concatenating the columns of the
    input objects.
    The returned DuckDBDataFrame object concatenates the metadata across the
    input objects.
    The metadata columns of the returned DuckDBDataFrame object are obtained
    by combining the metadata columns of the input object with
    \code{combineRows()}.
  }
}
}

\section{Displaying}{

The \code{show()} method for DuckDBDataFrame objects obeys global options
\code{showHeadLines} and \code{showTailLines} for controlling the number of
head and tail rows to display.
}

\examples{
# Mocking up a file:
tf <- tempfile(fileext = ".parquet")
on.exit(unlink(tf))
arrow::write_parquet(cbind(model = rownames(mtcars), mtcars), tf)

# Creating our DuckDB-backed data frame:
df <- DuckDBDataFrame(tf, datacols = colnames(mtcars), keycol = "model")
df

# Extraction yields a DuckDBColumn:
df$carb

# Slicing DuckDBDataFrame objects:
df[,1:5]
df[1:5,]

# Combining by DuckDBDataFrame and DuckDBColumn objects:
combined <- cbind(df, df)
class(combined)
combined2 <- cbind(df, some_new_name=df[,1])
class(combined2)

}
\author{
Patrick Aboyoun, Aaron Lun
}
\keyword{classes}
\keyword{methods}
