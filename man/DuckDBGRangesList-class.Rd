% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DuckDBGRangesList-class.R
\name{DuckDBGRangesList-class}
\alias{DuckDBGRangesList-class}
\alias{updateObject,DuckDBGRangesList-method}
\alias{length,DuckDBGRangesList-method}
\alias{names,DuckDBGRangesList-method}
\alias{names<-,DuckDBGRangesList-method}
\alias{elementNROWS,DuckDBGRangesList-method}
\alias{split,DuckDBGRanges,DuckDBColumn-method}
\alias{unlist,DuckDBGRangesList-method}
\alias{extractROWS,DuckDBGRangesList,ANY-method}
\alias{getListElement,DuckDBGRangesList-method}
\alias{head,DuckDBGRangesList-method}
\alias{tail,DuckDBGRangesList-method}
\alias{coerce,DuckDBGRangesList,DuckDBDataFrameList-method}
\alias{coerce,DuckDBGRangesList,CompressedGRangesList-method}
\alias{realize,DuckDBGRangesList-method}
\alias{show,DuckDBGRangesList-method}
\title{DuckDBGRangesList objects}
\description{
The DuckDBDataFrame class extends both \linkS4class{GRangesList} and
\linkS4class{DuckDBList} to represent a DuckDB table as a
\linkS4class{GRangesList} object.
}
\details{
The DuckDBGRangesList class extends the \linkS4class{GRangesList} instead of
\linkS4class{GenomicRangesList} class because the \code{rowRanges} slot
accepts either a \linkS4class{GenomicRanges} object or a
\linkS4class{GRangesList} object. As a result, it is necessary to override
certain methods that were inherited from \linkS4class{GRangesList} that would
have ideally been inherited from the \linkS4class{DuckDBList} class.
}
\section{Constructor}{

\describe{
  \item{\code{split(x, f)}:}{
    Creates a DuckDBGRangesList object.
    \describe{
      \item{\code{x}}{
        A DuckDBGRanges object to split.
      }
      \item{\code{f}}{
        A DuckDBColumn object to split \code{x} by.
      }
    }
  }
}
}

\section{Accessors}{

In the code snippets below, \code{x} is a DuckDBGRangesList object:
\describe{
  \item{\code{length(x)}:}{
    Get the number of elements in \code{x}.
  }
  \item{\code{names(x)}, \code{names(x) <- value}:}{
    Get or set the names of the elements of \code{x}.
  }
  \item{\code{mcols(x)}, \code{mcols(x) <- value}:}{
     Get or set the metadata columns.
  }
  \item{\code{elementNROWS(x)}:}{
    Get the length (or nb of row for a matrix-like object) of each of the
    elements.
  }
}
}

\section{Coercion}{

In the code snippets below, \code{x} is a DuckDBGRangesList object:
\describe{
  \item{\code{unlist(x)}:}{
    Returns the underlying DuckDBGRanges object.
  }
  \item{\code{as(from, "DuckDBDataFrameList")}:}{
    Creates a \linkS4class{DuckDBDataFrameList} object.
  }
  \item{\code{as(from, "CompressedGRangesList")}:}{
    Converts a DuckDBGRanges object to a CompressedGRangesList object. This
    conversion begins by transforming the DuckDBGRangesList into a
    \code{as(from, "DuckDBDataFrameList")}, then bringing the data into
    memory and contructing the GRangesList object.
  }
  \item{\code{realize(x, BACKEND = getAutoRealizationBackend())}:}{
    Realize an object into memory or on disk using the equivalent of
    \code{realize(as(x, "CompressedGRangesList"), BACKEND)}.
  }
}
}

\section{Subsetting}{

In the code snippets below, \code{x} is a DuckDBGRangesList object:
\describe{
  \item{\code{x[i]}:}{
    Returns a DuckDBGRangesList object containing the selected elements.
  }
  \item{\code{x[[i]]}:}{
    Return the selected DuckDBGRanges by \code{i}, where \code{i} is an
    numeric or character vector of length 1.
  }
  \item{\code{x$name}:}{
    Similar to \code{x[[name]]}, but \code{name} is taken literally as an
    element name.
  }
  \item{\code{head(x, n = 6L)}:}{
    If \code{n} is non-negative, returns the first n elements of \code{x}.
    If \code{n} is negative, returns all but the last \code{abs(n)} elements
    of \code{x}.
  }
  \item{\code{tail(x, n = 6L)}:}{
    If \code{n} is non-negative, returns the last n elements of \code{x}.
    If \code{n} is negative, returns all but the first \code{abs(n)} elements
    of \code{x}.
  }
}
}

\examples{
# Create an example data set with start and width columns:
df <- data.frame(id = head(letters, 10),
                 seqnames = rep.int(c("chr2", "chr2", "chr1", "chr3"), c(1, 3, 2, 4)),
                 start = 1:10, width = 10:1,
                 strand = strand(rep.int(c("-", "+", "*", "+", "-"), c(1, 2, 2, 3, 2))),
                 score = 1:10,
                 GC = seq(1, 0, length = 10),
                 group = rep(c("gr1", "gr2", "gr3", "gr4"), 1:4))
tf <- tempfile(fileext = ".parquet")
on.exit(unlink(tf))
arrow::write_parquet(df, tf)

# Create the DuckDBGRangesList object
seqinfo <- Seqinfo(paste0("chr", 1:3), c(1000, 2000, 1500), NA, "mock1")
gr <- DuckDBGRanges(tf, seqnames = "seqnames", start = "start", width = "width",
                    strand = "strand", mcols = c("score", "GC", "group"),
                    seqinfo = seqinfo, keycols = "id")
grlist <- split(gr, gr$group)
grlist

}
\author{
Patrick Aboyoun
}
\keyword{classes}
\keyword{methods}
