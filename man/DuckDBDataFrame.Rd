% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DuckDBDataFrame.R
\name{DuckDBDataFrame}
\alias{DuckDBDataFrame}
\alias{DuckDBDataFrame-class}
\alias{makeNakedCharacterMatrixForDisplay,DuckDBDataFrame-method}
\alias{show,DuckDBDataFrame-method}
\alias{length,DuckDBDataFrame-method}
\alias{names,DuckDBDataFrame-method}
\alias{rownames<-,DuckDBDataFrame-method}
\alias{names<-,DuckDBDataFrame-method}
\alias{extractROWS,DuckDBDataFrame,ANY-method}
\alias{head,DuckDBDataFrame-method}
\alias{tail,DuckDBDataFrame-method}
\alias{extractCOLS,DuckDBDataFrame-method}
\alias{[,DuckDBDataFrame,ANY,ANY,ANY-method}
\alias{[[,DuckDBDataFrame-method}
\alias{replaceROWS,DuckDBDataFrame-method}
\alias{replaceCOLS,DuckDBDataFrame-method}
\alias{normalizeSingleBracketReplacementValue,DuckDBDataFrame-method}
\alias{[[<-,DuckDBDataFrame-method}
\alias{bindROWS,DuckDBDataFrame-method}
\alias{cbind,DuckDBDataFrame-method}
\alias{cbind.DuckDBDataFrame}
\alias{as.data.frame,DuckDBDataFrame-method}
\title{DuckDB-backed DataFrame}
\usage{
DuckDBDataFrame(conn, keycols, datacols, ...)
}
\arguments{
\item{conn}{Either a string containing the path to the underlying data files
or a \code{tbl_duckdb_connection} object.}

\item{keycols}{An optional character vector or a list of character vectors
containing the names of the columns that comprise the primary key. If missing,
a \code{row_number} column is created as an identifier.}

\item{datacols}{Either a character vector containing the names of the columns
in the DuckDB table that specify the data columns.}

\item{...}{Further arguments to be passed to \code{read_parquet}.}
}
\value{
A DuckDBDataFrame where each column is a \linkS4class{DuckDBColumn}.
}
\description{
Create a DuckDB-backed \linkS4class{DataFrame}
}
\details{
The DuckDBDataFrame is essentially just a \linkS4class{DataFrame} of \linkS4class{DuckDBColumn} objects.
It is primarily useful for indicating that the R representation is consistent with the underlying data
(e.g., no delayed filter/mutate operations have been applied, no data has been added from other files).
Thus, users can specialize code paths for a DuckDBDataFrame to operate directly on the underlying data.
}
\examples{
# Mocking up a file:
tf <- tempfile()
on.exit(unlink(tf))
arrow::write_parquet(cbind(model = rownames(mtcars), mtcars), tf)

# Creating our DuckDB-backed data frame:
df <- DuckDBDataFrame(tf, keycols = "model")
df

# Extraction yields a DuckDBColumn:
df$carb

# Slicing DuckDBDataFrame objects:
df[,1:5]
df[1:5,]

# Combining by DuckDBDataFrame and DuckDBColumn objects:
combined <- cbind(df, df)
class(combined)
combined2 <- cbind(df, some_new_name=df[,1])
class(combined2)

}
\author{
Aaron Lun, Patrick Aboyoun
}
