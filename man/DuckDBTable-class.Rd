% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DuckDBTable-class.R
\name{DuckDBTable-class}
\alias{DuckDBTable-class}
\alias{dbconn,DuckDBTable-method}
\alias{tblconn,DuckDBTable-method}
\alias{nrow,DuckDBTable-method}
\alias{ncol,DuckDBTable-method}
\alias{rownames,DuckDBTable-method}
\alias{colnames,DuckDBTable-method}
\alias{colnames<-,DuckDBTable-method}
\alias{coltypes}
\alias{coltypes,DuckDBTable-method}
\alias{coltypes<-}
\alias{coltypes<-,DuckDBTable-method}
\alias{dimtbls}
\alias{dimtbls,DuckDBTable-method}
\alias{dimtbls<-}
\alias{dimtbls<-,DuckDBTable-method}
\alias{DuckDBTable}
\alias{all.equal.DuckDBTable}
\alias{[,DuckDBTable,ANY,ANY,ANY-method}
\alias{extractROWS,DuckDBTable,ANY-method}
\alias{extractCOLS,DuckDBTable-method}
\alias{head,DuckDBTable-method}
\alias{tail,DuckDBTable-method}
\alias{subset,DuckDBTable-method}
\alias{bindROWS,DuckDBTable-method}
\alias{bindCOLS,DuckDBTable-method}
\alias{as.data.frame,DuckDBTable-method}
\alias{as.env,DuckDBTable-method}
\alias{show,DuckDBTable-method}
\title{DuckDBTable objects}
\description{
The DuckDBTable class extends the \linkS4class{RectangularData} virtual
class for DuckDB tables by wrapping a tbl_duckdb_connection object.
}
\details{
The DuckDBTable class provides a way to define a DuckDB table as a
\linkS4class{RectangularData} object. It supports \emph{standard 2D API}
such as \code{dim()}, \code{nrow()}, \code{ncol()}, \code{dimnames()},
\code{x[i, j]} and \code{cbind()}, but does not support \code{rbind()}.
}
\section{Constructor}{

\describe{
  \item{\code{DuckDBTable(conn, datacols = colnames(conn), keycols = NULL, dimtbls = NULL, type = NULL)}:}{
    Creates a DuckDBTable object.
    \describe{
      \item{\code{conn}}{
        Either a character vector containing the paths to parquet, csv, or
        gzipped csv data files; a string that defines a duckdb \code{read_*}
        data source; a DuckDBDataFrame object; or a tbl_duckdb_connection
        object.
      }
      \item{\code{datacols}}{
        Either a character vector of column names from \code{conn} or a
        named \code{expression} that will be evaluated in the context of
        \code{conn} that defines the data.
      }
      \item{\code{keycols}}{
        An optional character vector of column names from \code{conn} that
        will define the set of foreign keys in the underlying table, or a
        named list of character vectors where the names of the list define
        the foreign keys and the character vectors set the distinct values
        for those keys. If missing, a \code{row_number} column is created
        as an identifier.
      }
      \item{\code{dimtbls}}{
        A optional named \code{DataFrameList} that specifies the dimension
        tables associated with the \code{keycols}. The name of the list
        elements match the names of the \code{keycols} list. Additionally,
        the \code{DataFrame} objects have row names that match the distinct
        values of the corresponding \code{keycols} list element and columns
        that define partitions in the data table for efficient querying.
      }
      \item{\code{type}}{
        An optional named character vector where the names specify the
        column names and the values specify the column type; one of
        \code{"logical"}, \code{"integer"}, \code{"integer64"},
        \code{"double"}, or \code{"character"}.
      }
    }
  }
}
}

\section{Accessors}{

In the code snippets below, \code{x} is a DuckDBTable object:
\describe{
  \item{\code{dim(x)}:}{
    Length two integer vector defined as \code{c(nrow(x), ncol(x))}.
  }
  \item{\code{nrow(x)}, \code{ncol(x)}:}{
    Get the number of rows and columns, respectively.
  }
  \item{\code{NROW(x)}, \code{NCOL(x)}:}{
    Same as \code{nrow(x)} and \code{ncol(x)}, respectively.
  }
  \item{\code{dimnames(x)}:}{
    Length two list of character vectors defined as
    \code{list(rownames(x), colnames(x))}.
  }
  \item{\code{rownames(x)}, \code{colnames(x)}:}{
    Get the names of the rows and columns, respectively.
  }
  \item{\code{coltypes(x)}, \code{coltypes(x) <- value}:}{
    Get or set the data type of the columns; one of \code{"logical"},
    \code{"integer"}, \code{"integer64"}, \code{"double"}, or
    \code{"character"}.
  }
  \item{\code{dimtbls(x)}, \code{dimtbls(x) <- value}:}{
    Get or set the list of dimension tables used to define partitions for
    efficient queries.
  }
}
}

\section{Coercion}{

\describe{
  \item{\code{as.data.frame(x)}:}{
    Coerces \code{x} to a data.frame.
  }
}
}

\section{Subsetting}{

In the code snippets below, \code{x} is a DuckDBTable object:
\describe{
  \item{\code{x[i, j]}:}{
    Return a new DuckDBTable of the same class as \code{x} made of the
    selected rows and columns.
  }
  \item{\code{head(x, n = 6L)}:}{
    If \code{n} is non-negative, returns the first n rows of \code{x}.
    If \code{n} is negative, returns all but the last \code{abs(n)} rows of
    \code{x}.
  }
  \item{\code{tail(x, n = 6L)}:}{
    If \code{n} is non-negative, returns the last n rows of \code{x}.
    If \code{n} is negative, returns all but the first \code{abs(n)} rows of
    \code{x}.
  }
}
}

\examples{
# Create a data.frame from the Titanic data
df <- do.call(expand.grid, c(dimnames(Titanic), stringsAsFactors = FALSE))
df$fate <- as.integer(Titanic[as.matrix(df)])

# Write data to a parquet file
tf <- tempfile(fileext = ".parquet")
on.exit(unlink(tf))
arrow::write_parquet(df, tf)

tbl <- DuckDBTable(tf, datacols = "fate", keycols = c("Class", "Sex", "Age", "Survived"))

}
\seealso{
\itemize{
  \item \code{\link{DuckDBTable-utils}} for the utilities
  \item \code{\link[S4Vectors]{RectangularData}} for the base class
}
}
\author{
Patrick Aboyoun
}
\keyword{classes}
\keyword{methods}
