% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DuckDBTable-class.R
\name{DuckDBTable-class}
\alias{DuckDBTable-class}
\alias{dbconn,DuckDBTable-method}
\alias{tblconn,DuckDBTable-method}
\alias{nrow,DuckDBTable-method}
\alias{ncol,DuckDBTable-method}
\alias{rownames,DuckDBTable-method}
\alias{colnames,DuckDBTable-method}
\alias{colnames<-,DuckDBTable-method}
\alias{coltypes}
\alias{coltypes,DuckDBTable-method}
\alias{coltypes<-}
\alias{coltypes<-,DuckDBTable-method}
\alias{DuckDBTable}
\alias{all.equal.DuckDBTable}
\alias{[,DuckDBTable,ANY,ANY,ANY-method}
\alias{extractROWS,DuckDBTable,ANY-method}
\alias{extractCOLS,DuckDBTable-method}
\alias{head,DuckDBTable-method}
\alias{tail,DuckDBTable-method}
\alias{subset,DuckDBTable-method}
\alias{bindROWS,DuckDBTable-method}
\alias{bindCOLS,DuckDBTable-method}
\alias{as.data.frame,DuckDBTable-method}
\alias{as.env,DuckDBTable-method}
\alias{show,DuckDBTable-method}
\title{DuckDBTable objects}
\description{
The DuckDBTable class extends the \linkS4class{RectangularData} virtual
class for DuckDB tables by wrapping a tbl_duckdb_connection object.
}
\details{
The DuckDBTable class provides a way to define a DuckDB table as a
\linkS4class{RectangularData} object. It supports \emph{standard 2D API}
such as \code{dim()}, \code{nrow()}, \code{ncol()}, \code{dimnames()},
\code{x[i, j]} and \code{cbind()}, but does not support \code{rbind()}.
}
\section{Constructor}{

\describe{
  \item{\code{DuckDBTable(conn, datacols = colnames(conn), keycols = NULL, type = NULL)}:}{
    Creates a DuckDBTable object.
    \describe{
      \item{\code{conn}}{
        Either a character vector containing the paths to parquet, csv, or
        gzipped csv data files; a string that defines a duckdb \code{read_*}
        data source; a DuckDBDataFrame object; or a tbl_duckdb_connection
        object.
      }
      \item{\code{datacols}}{
        Either a character vector of column names from \code{conn} or a
        named \code{expression} that will be evaluated in the context of
        \code{conn} that defines the data.
      }
      \item{\code{keycols}}{
        An optional character vector of column names from \code{conn} that
        will define the primary key, or a named list of character vectors
        where the names of the list define the key and the character vectors
        set the distinct values for the key. If missing, a \code{row_number}
        column is created as an identifier.
      }
      \item{\code{type}}{
        An optional named character vector where the names specify the
        column names and the values specify the column type; one of
        \code{"logical"}, \code{"integer"}, \code{"integer64"},
        \code{"double"}, or \code{"character"}.
      }
    }
  }
}
}

\section{Accessors}{

In the code snippets below, \code{x} is a DuckDBTable object:
\describe{
  \item{\code{dim(x)}:}{
    Length two integer vector defined as \code{c(nrow(x), ncol(x))}.
  }
  \item{\code{nrow(x)}, \code{ncol(x)}:}{
    Get the number of rows and columns, respectively.
  }
  \item{\code{NROW(x)}, \code{NCOL(x)}:}{
    Same as \code{nrow(x)} and \code{ncol(x)}, respectively.
  }
  \item{\code{dimnames(x)}:}{
    Length two list of character vectors defined as
    \code{list(rownames(x), colnames(x))}.
  }
  \item{\code{rownames(x)}, \code{colnames(x)}:}{
    Get the names of the rows and columns, respectively.
  }
}
}

\section{Coercion}{

\describe{
  \item{\code{as.data.frame(x)}:}{
    Coerces \code{x} to a data.frame.
  }
}
}

\section{Subsetting}{

In the code snippets below, \code{x} is a DuckDBTable object:
\describe{
  \item{\code{x[i, j]}:}{
    Return a new DuckDBTable of the same class as \code{x} made of the
    selected rows and columns.
  }
  \item{\code{head(x, n = 6L)}:}{
    If \code{n} is non-negative, returns the first n rows of \code{x}.
    If \code{n} is negative, returns all but the last \code{abs(n)} rows of
    \code{x}.
  }
  \item{\code{tail(x, n = 6L)}:}{
    If \code{n} is non-negative, returns the last n rows of \code{x}.
    If \code{n} is negative, returns all but the first \code{abs(n)} rows of
    \code{x}.
  }
  \item{\code{subset(x, subset, select)}:}{
    Return a new DuckDBTable using:
    \describe{
      \item{subset}{logical expression indicating rows to keep, where missing
         values are taken as FALSE.}
       \item{select}{expression indicating columns to keep.}
    }
  }
}
}

\examples{
# Create a data.frame from the Titanic data
df <- do.call(expand.grid, c(dimnames(Titanic), stringsAsFactors = FALSE))
df$fate <- as.integer(Titanic[as.matrix(df)])

# Write data to a parquet file
tf <- tempfile(fileext = ".parquet")
on.exit(unlink(tf))
arrow::write_parquet(df, tf)

tbl <- DuckDBTable(tf, datacols = "fate", keycols = c("Class", "Sex", "Age", "Survived"))

}
\author{
Patrick Aboyoun
}
\keyword{classes}
\keyword{methods}
