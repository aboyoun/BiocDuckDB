% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DuckDBDataFrameList-class.R
\name{DuckDBDataFrameList-class}
\alias{DuckDBDataFrameList-class}
\alias{ncols,DuckDBDataFrameList-method}
\alias{rownames<-,DuckDBDataFrameList-method}
\alias{colnames<-,DuckDBDataFrameList-method}
\alias{commonColnames,DuckDBDataFrameList-method}
\alias{columnMetadata,DuckDBDataFrameList-method}
\alias{columnMetadata<-,DuckDBDataFrameList-method}
\alias{split,DuckDBDataFrame,DuckDBColumn-method}
\alias{coerce,DuckDBDataFrameList,DFrameList-method}
\alias{realize,DuckDBDataFrameList-method}
\title{DuckDBDataFrameList objects}
\description{
The DuckDBDataFrame class extends both \linkS4class{SplitDataFrameList} and
\linkS4class{DuckDBList} to represent a DuckDB table as a
\linkS4class{SplitDataFrameList} object.
}
\section{Constructor}{

\describe{
  \item{\code{split(x, f)}:}{
    Creates a DuckDBDataFrameList object.
    \describe{
      \item{\code{x}}{
        A DuckDBDataFrame object to split.
      }
      \item{\code{f}}{
        A DuckDBColumn object to split \code{x} by.
      }
    }
  }
}
}

\section{Accessors}{

In the code snippets below, \code{x} is a DuckDBDataFrameList object:
\describe{
  \item{\code{dims(x)}:}{
    Get the two-column matrix indicating the number of rows and columns for
    each of the list elements.
  }
  \item{\code{nrows(x)}, \code{ncols(x)}:}{
    Get the number of rows and columns, respectively, for each of the list
    elements.
  }
  \item{\code{dimnames(x)}:}{
    Get the list of two \linkS4class{CharacterList}s, the first holding the
    rownames and the second the column names.
  }
  \item{\code{rownames(x)}, \code{colnames(x)}:}{
    Get the \linkS4class{CharacterList} of row and colum names, respectively.
  }
  \item{\code{commonColnames(x)}, \code{commonColnames(x) <- value}:}{
    Get or set the character vector of column names present in the individual
    DataFrames in \code{x}.
  }
  \item{\code{columnMetadata(x)}, \code{columnMetadata(x) <- value}:}{
    Get the \linkS4class{DataFrame} of metadata along the columns, i.e.,
    where each column in \code{x} is represented by a row in the metadata.
    The metadata is common across all elements of \code{x}. Note that calling
    \code{mcols(x)} returns the metadata on the \linkS4class{DataFrame}
    elements of \code{x}.
  }
}
}

\section{Coercion}{

In the code snippets below, \code{x} is a DuckDBDataFrameList object:
\describe{
  \item{\code{unlist(x)}:}{
    Returns the underlying DuckDBDataFrame object.
  }
  \item{\code{as(from, "DFrameList")}:}{
    Converts a DuckDBDataFrameList object to a DFrameList object. This
    process involves first loading the data into memory using
    \code{as(from, "DFrame")}. The resulting DFrame is then split into a
    DFrameList. Additionally, any associated metadata and mcols (metadata
    columns) are preserved and added to the DFrameList, if they exist.
  }
  \item{\code{realize(x, BACKEND = getAutoRealizationBackend())}:}{
    Realize an object into memory or on disk using the equivalent of
    \code{realize(as(x, "DFrameList"), BACKEND)}.
  }
}
}

\section{Subsetting}{

In the code snippets below, \code{x} is a DuckDBDataFrameList object:
\describe{
  \item{\code{x[i]}:}{
    Returns a DuckDBDataFrameList object containing the selected elements.
  }
  \item{\code{x[[i]]}:}{
    Return the selected DuckDBDataFrame by \code{i}, where \code{i} is an
    numeric or character vector of length 1.
  }
  \item{\code{x$name}:}{
    Similar to \code{x[[name]]}, but \code{name} is taken literally as an
    element name.
  }
  \item{\code{head(x, n = 6L)}:}{
    If \code{n} is non-negative, returns the first n elements of \code{x}.
    If \code{n} is negative, returns all but the last \code{abs(n)} elements
    of \code{x}.
  }
  \item{\code{tail(x, n = 6L)}:}{
    If \code{n} is non-negative, returns the last n elements of \code{x}.
    If \code{n} is negative, returns all but the first \code{abs(n)} elements
    of \code{x}.
  }
}
}

\examples{
# Mocking up a file:
tf <- tempfile(fileext = ".parquet")
on.exit(unlink(tf))
arrow::write_parquet(cbind(model = rownames(mtcars), mtcars), tf)

# Creating our DuckDB-backed data frame:
df <- DuckDBDataFrame(tf, datacols = colnames(mtcars), keycols = "model")
dflist <- split(df, df$cyl)
dflist

}
\author{
Patrick Aboyoun
}
\keyword{classes}
\keyword{methods}
