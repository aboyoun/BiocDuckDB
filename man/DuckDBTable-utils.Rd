% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DuckDBTable-utils.R
\name{DuckDBTable-utils}
\alias{DuckDBTable-utils}
\alias{Ops,DuckDBTable,DuckDBTable-method}
\alias{Ops,DuckDBTable,atomic-method}
\alias{Ops,atomic,DuckDBTable-method}
\alias{Math,DuckDBTable-method}
\alias{Summary,DuckDBTable-method}
\alias{is.finite,DuckDBTable-method}
\alias{is.infinite,DuckDBTable-method}
\alias{is.nan,DuckDBTable-method}
\alias{mean,DuckDBTable-method}
\alias{var,DuckDBTable,ANY-method}
\alias{sd,DuckDBTable-method}
\alias{median.DuckDBTable}
\alias{quantile.DuckDBTable}
\alias{mad,DuckDBTable-method}
\alias{IQR,DuckDBTable-method}
\alias{rowSums,DuckDBTable-method}
\alias{colSums,DuckDBTable-method}
\alias{unique,DuckDBTable-method}
\alias{\%in\%,DuckDBTable,ANY-method}
\alias{table,DuckDBTable-method}
\alias{is_nonzero,DuckDBTable-method}
\alias{nzcount,DuckDBTable-method}
\alias{is_sparse,DuckDBTable-method}
\alias{st_area.DuckDBTable}
\alias{st_as_binary.DuckDBTable}
\alias{st_as_text.DuckDBTable}
\alias{st_boundary.DuckDBTable}
\alias{st_centroid.DuckDBTable}
\alias{st_convex_hull.DuckDBTable}
\alias{st_exterior_ring.DuckDBTable}
\alias{st_is_valid.DuckDBTable}
\alias{st_line_merge.DuckDBTable}
\alias{st_make_valid.DuckDBTable}
\alias{st_normalize.DuckDBTable}
\alias{st_point_on_surface.DuckDBTable}
\alias{st_reverse.DuckDBTable}
\title{Common operations on DuckDBTable objects}
\description{
Common operations on \linkS4class{DuckDBTable} objects.
}
\section{Group Generics}{

DuckDBTable objects have support for S4 group generic functionality:
\describe{
  \item{\code{Arith}}{\code{"+"}, \code{"-"}, \code{"*"}, \code{"^"},
    \code{"\%\%"}, \code{"\%/\%"}, \code{"/"}}
  \item{\code{Compare}}{\code{"=="}, \code{">"}, \code{"<"}, \code{"!="},
    \code{"<="}, \code{">="}}
  \item{\code{Logic}}{\code{"&"}, \code{"|"}}
  \item{\code{Ops}}{\code{"Arith"}, \code{"Compare"}, \code{"Logic"}}
  \item{\code{Math}}{\code{"abs"}, \code{"sign"}, \code{"sqrt"},
    \code{"ceiling"}, \code{"floor"}, \code{"trunc"}, \code{"log"},
    \code{"log10"}, \code{"log2"}, \code{"acos"}, \code{"acosh"},
    \code{"asin"}, \code{"asinh"}, \code{"atan"}, \code{"atanh"},
    \code{"exp"}, \code{"expm1"}, \code{"cos"}, \code{"cosh"},
    \code{"sin"}, \code{"sinh"}, \code{"tan"}, \code{"tanh"},
    \code{"gamma"}, \code{"lgamma"}}
  \item{\code{Summary}}{\code{"max"}, \code{"min"}, \code{"range"},
    \code{"prod"}, \code{"sum"}, \code{"any"}, \code{"all"}}
 }
 See \link[methods]{S4groupGeneric} for more details.
}

\section{Numerical Data Methods}{

In the code snippets below, \code{x} is a DuckDBTable object:
\describe{
  \item{\code{is.finite(x)}:}{
    Returns a DuckDBTable containing logicals that indicate which values are
    finite.
  }
  \item{\code{is.infinite(x)}:}{
    Returns a DuckDBTable containing logicals that indicate which values are
    infinite.
  }
  \item{\code{is.nan(x)}:}{
    Returns a DuckDBTable containing logicals that indicate which values are
    Not a Number.
  }
  \item{\code{mean(x)}:}{
    Calculates the mean of \code{x}.
  }
  \item{\code{var(x)}:}{
    Calculates the variance of \code{x}.
  }
  \item{\code{sd(x)}:}{
    Calculates the standard deviation of \code{x}.
  }
  \item{\code{median(x)}:}{
    Calculates the median of \code{x}.
  }
  \item{\code{quantile(x, probs = seq(0, 1, 0.25), names = TRUE, type = 7)}:}{
    Calculates the specified quantiles of \code{x}.
    \describe{
      \item{\code{probs}}{A numeric vector of probabilities with values in
        [0,1].}
      \item{\code{names}}{If \code{TRUE}, the result has names describing the
        quantiles.}
      \item{\code{type}}{Either 1 or 7 that specifies the quantile algorithm
        detailed in \code{\link[stats]{quantile}}.}
    }
  }
  \item{\code{mad(x, constant = 1.4826)}:}{
    Calculates the median absolute deviation of \code{x}.
    \describe{
      \item{\code{constant}}{The scale factor.}
    }
  }
  \item{\code{IQR(x, type = 7)}:}{
    Calculates the interquartile range of \code{x}.
    \describe{
      \item{\code{type}}{Either 1 or 7 that specifies the quantile algorithm
        detailed in \code{\link[stats]{quantile}}.}
    }
  }
  \item{\code{rowSums(x, dims = 1)}:}{
    Calculates the row sums of \code{x}.
    \describe{
      \item{\code{dims}}{An integer specifying which dimensions to sum over,
        namely \code{dims + 1}, \ldots.}
    }
  }
  \item{\code{colSums(x, dims = 1)}:}{
    Calculates the column sums of \code{x}.
    \describe{
      \item{\code{dims}}{An integer specifying which dimensions to sum over,
        namely \code{1:dims}.}
    }
  }
}
}

\section{General Methods}{

In the code snippets below, \code{x} is a DuckDBTable object:
\describe{
  \item{\code{unique(x)}:}{
    Returns a DuckDBTable containing the distinct rows.
  }
  \item{\code{x \%in\% table}:}{
    Returns a DuckDBTable containing logicals that indicate if the
    values in each of the columns of \code{x} are in \code{table}.
  }
  \item{\code{table(...)}:}{
    Returns a table containing the counts across the distinct values.
  }
}
}

\section{Sparisty Methods}{

In the code snippets below, \code{x} is a DuckDBTable object:
\describe{
  \item{\code{is_nonzero(x)}:}{
    Returns a DuckDBTable containing logicals that indicate if the
    values in each of the columns of \code{x} are non-zero.
  }
  \item{\code{nzcount(x)}:}{
    Returns the total number of non-zero values.
  }
  \item{\code{is_sparse(x)}:}{
    Returns \code{TRUE} since data are stored in a sparse array representation.
  }
}
}

\section{Spatial Methods}{

In the code snippets below, \code{x} is a DuckDBTable object:
\describe{
  \item{\code{st_area(x)}:}{
    Returns a DuckDBTable containing the areas of geometries.
  }
  \item{\code{st_as_binary(x, hex = FALSE)}:}{
    Returns the DuckDBTable containing either WKB if \code{hex = FALSE} or
    HEXWKB if \code{hex = TRUE} representations of geometries.
  }
  \item{\code{st_as_text(x, geojson = FALSE)}:}{
    Returns the DuckDBTable containing either WKT if \code{geojson = FALSE} or
    GeoJSON if \code{geojson = TRUE} representations of geometries.
  }
  \item{\code{st_boundary(x)}:}{
    Returns a DuckDBTable containing the boundaries of geometries.
  }
  \item{\code{st_centroid(x)}:}{
    Returns a DuckDBTable containing the centroids of geometries.
  }
  \item{\code{st_convex_hull(x)}:}{
    Returns a DuckDBTable containing the convex hulls of geometries.
  }
  \item{\code{st_exterior_ring(x)}:}{
    Returns a DuckDBTable containing the exterior rings of geometries.
  }
  \item{\code{st_is_valid(x)}:}{
    Returns a DuckDBTable containing logicals that indicate if the
    geometries are valid.
  }
  \item{\code{st_line_merge(x, directed = FALSE)}:}{
    Returns a DuckDBTable containing the merged lines of geometries,
    optionally taking direction into account.
  }
  \item{\code{st_make_valid(x)}:}{
    Returns a DuckDBTable containing valid geometries.
  }
  \item{\code{st_normalize(x)}:}{
    Returns a DuckDBTable containing normalized geometries.
  }
  \item{\code{st_point_on_surface(x)}:}{
    Returns a DuckDBTable containing a point on the surface of the input
    geometry.
  }
  \item{\code{st_reverse(x)}:}{
    Returns a DuckDBTable containing geometries with the vertice order
    reversed.
  }
}
}

\author{
Patrick Aboyoun
}
\keyword{methods}
\keyword{utilities}
